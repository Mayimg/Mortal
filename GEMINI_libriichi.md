
# `libriichi` ライブラリ詳細レポート

このレポートは `libriichi` ライブラリの構造と機能について詳細に解説します。

## 1. 全体アーキテクチャ

`libriichi` は、麻雀のルールに基づいたシミュレーション、エージェント（AI）、データセット生成、統計分析などの機能を提供するライブラリです。Pythonから利用できるように、多くの機能がPyO3を介して公開されています。

### 処理フローの概要

外部から `libriichi` ライブラリを利用する場合、主に以下の2つのシナリオが考えられます。

1.  **ゲームシミュレーション (`arena` モジュール):**
    *   `arena::OneVsThree` や `arena::TwoVsTwo` などのクラスを利用して、複数のエージェント（AI）同士の対戦シミュレーションを実行します。
    *   `arena::game::BatchGame` が中心となり、指定された数のゲームを並列に実行します。
    *   各ゲームは `arena::board::Board` によって管理され、局の進行、牌山やドラの生成、スコア計算などが行われます。
    *   `arena::board::BoardState` が各局の状態を管理し、`state::PlayerState` を通じて各プレイヤーの状態を更新します。
    *   各プレイヤーの行動選択のタイミングで、`agent::Agent` または `agent::BatchAgent` の `react` メソッドが呼び出され、エージェントが次の行動を決定します。
    *   エージェントは `state::PlayerState` から観測情報を取得し、それに基づいて行動を決定します。Mortalのような深層学習ベースのエージェントは、観測情報を `state::PlayerState::encode_obs` でエンコードされた多次元配列として受け取ります。
    *   ゲームが終了すると、`arena::result::GameResult` が生成され、対戦結果（スコア、ログなど）が返されます。

2.  **データセット生成・統計分析 (`dataset`, `stat` モジュール):**
    *   `dataset::GameplayLoader` や `stat::Stat` などのクラスを利用して、既存のmjai形式のゲームログファイルを解析します。
    *   `GameplayLoader` は、ログから各プレイヤーの各手番における観測情報（`obs`）、行動（`actions`）、行動マスク（`masks`）などを抽出し、機械学習用のデータセットを生成します。この際、内部で `state::PlayerState` を利用して各時点の状態を再現します。
    *   `Stat` は、ログから和了率、放銃率、立直率などの様々な統計情報を計算します。

## 2. 主要モジュール詳細

### `lib.rs`

ライブラリ全体のエントリーポイントです。Pythonモジュール `libriichi` を定義し、各サブモジュールを登録します。また、アロケータとして `mimalloc` を利用する設定や、各種`clippy`のlint設定が含まれています。

### `tile.rs`

麻雀牌の表現と操作を定義します。

*   **`Tile` 構造体:**
    *   麻雀牌を内部的に `u8` で表現します。
    *   `new_unchecked`, `as_u8`, `as_usize` などのメソッドを提供します。
    *   `deaka`, `akaize` で赤ドラと通常牌の変換を行います。
    *   `is_aka`, `is_jihai`, `is_yaokyuu` などで牌の性質を判定します。
    *   `next`, `prev` で次の牌、前の牌を取得します（数牌は循環し、字牌も風牌・三元牌でそれぞれ循環します）。
    *   `augment` は、萬子を筒子に、筒子を萬子に変換する特殊な操作です（主にデータ拡張用）。
    *   `cmp_discard_priority` で、一般的なセオリーに基づいた捨て牌の優先順位を比較します。
*   **`InvalidTile` エラー:**
    *   不正な牌IDや文字列から `Tile` を生成しようとした場合に返されます。
*   **マクロ:**
    *   `t!`, `tu8!`, `tuz!` などのマクロが `macros.rs` で定義されており、コンパイル時に牌を安全かつ簡潔に表現できます。

### `hand.rs`

手牌の文字列表現（"123m 456p"のような形式）と内部表現（`[u8; 34]` や `[u8; 37]`）の相互変換を行います。主にテストやデバッグで利用されます。

*   **`hand_with_aka(s: &str) -> Result<[u8; 37]>`:**
    *   赤ドラを含む文字列から、37種の牌の枚数を表す配列を生成します。
*   **`hand(s: &str) -> Result<[u8; 34]>`:**
    *   赤ドラを含まない34種の牌の枚数を表す配列を生成します。
*   **`tile37_to_vec`, `tile34_to_vec`:**
    *   牌の枚数配列から `Vec<Tile>` に変換します。
*   **`tiles_to_string`:**
    *   牌の枚数配列と赤ドラ情報から文字列に変換します。

### `algo` ディレクトリ

麻雀の主要なアルゴリズムを実装しています。

#### `shanten.rs`

向聴数（シャンテン数）を計算するモジュールです。

*   **`calc_normal(tiles: &[u8; 34], len_div3: u8) -> i8`:**
    *   国士無双と七対子を除いた、一般形（4面子1雀頭）の向聴数を計算します。`len_div3` は副露（チー、ポン、明槓）の数です。
*   **`calc_chitoi(tiles: &[u8; 34]) -> i8`:**
    *   七対子の向聴数を計算します。
*   **`calc_kokushi(tiles: &[u8; 34]) -> i8`:**
    *   国士無双の向聴数を計算します。
*   **`calc_all(tiles: &[u8; 34], len_div3: u8) -> i8`:**
    *   一般形、七対子、国士無双の向聴数をすべて計算し、最も小さい値を返します。

#### `agari.rs`

和了判定と役の判定、符計算を行います。

*   **`Agari` enum:**
    *   和了の状態を表します。`Normal { fu, han }`（通常手）と `Yakuman(u8)`（役満）の2種類があります。
*   **`AgariCalculator` 構造体:**
    *   和了判定に必要な情報（手牌、副露、場風、自風、和了牌など）を保持します。
*   **`AgariCalculator::search_yakus() -> Option<Agari>`:**
    *   手牌が和了形かを判定し、和了している場合は最も点数が高くなる役の組み合わせと符、飜数を計算して `Agari` を返します。役満も判定します。
*   **`AgariCalculator::agari(additional_hans: u8, doras: u8) -> Option<Agari>`:**
    *   `search_yakus` の結果に、立直やドラなどの追加の飜数を加えて最終的な `Agari` を計算します。
*   **`check_ankan_after_riichi(...) -> bool`:**
    *   立直後に暗槓が可能か（待ちが変わらないか）を判定します。

#### `point.rs`

符と飜数から点数を計算します。

*   **`Point` 構造体:**
    *   ロン和了時の点数 (`ron`)、子ツモ時の子の支払い (`tsumo_ko`)、親ツモ時の支払い (`tsumo_oya`) を保持します。
*   **`Point::calc(is_oya: bool, fu: u8, han: u8) -> Self`:**
    *   親か子か、符、飜数から点数を計算します。
*   **`Point::yakuman(is_oya: bool, count: i32) -> Self`:**
    *   役満の点数を計算します（n倍役満に対応）。

#### `sp` ディレクトリ

シングルプレイヤー（1人麻雀）のシミュレーションに関連するモジュールです。主に期待値計算などに使われます。

### `state` ディレクトリ

プレイヤー視点のゲーム状態を管理するモジュールです。

#### `player_state.rs`

*   **`PlayerState` 構造体:**
    *   あるプレイヤーから見たゲームのすべての情報を保持します。
    *   手牌 (`tehai`)、河 (`kawa`)、副露、ドラ、点数、他家の情報など、観測可能な状態をすべて含みます。
    *   この構造体が `libriichi` の中核的なデータ構造であり、状態更新、行動決定、観測情報エンコードの基盤となります。

#### `update.rs`

*   **`PlayerState::update(...)`:**
    *   `mjai::Event` を受け取り、`PlayerState` の内部状態を更新します。
    *   例えば、`Tsumo` イベントを受け取ると手牌を追加し、`Dahai` イベントを受け取ると手牌を減らして河に追加します。
    *   状態更新後、次に取りうる行動の候補 `ActionCandidate` を返します。

#### `action.rs`

*   **`ActionCandidate` 構造体:**
    *   現在の状態でプレイヤーが実行可能な行動（打牌、チー、ポン、カン、立直、和了など）を `bool` 値で保持します。
    *   `PlayerState::update` の返り値として使われます。

#### `obs_repr.rs`

*   **`PlayerState::encode_obs(...)`:**
    *   `PlayerState` の内部状態を、Mortalのような深層学習モデルへの入力となる多次元配列 (`ndarray::Array2<f32>`) にエンコードします。
    *   手牌、河、ドラ、点数、他家の情報など、様々な情報が複数のチャンネルに分けてエンコードされます。
    *   `version` 引数によって、エンコードする特徴量のセットを切り替えることができます。

#### `agent_helper.rs`

*   `PlayerState` のヘルパーメソッド群です。
    *   **`discard_candidates_aka()`:** 捨て牌可能な牌のリストを返します。立直中は待ちが変わらない牌のみが対象になります。
    *   **`rule_based_agari()`:** ルールベースで和了すべきかどうかを判断します（例：オーラスでの順位を考慮）。
    *   **`agari_points(...)`:** 和了時の点数を計算します。内部で `AgariCalculator` を利用します。
    *   **`single_player_tables()`:** シングルプレイヤーシミュレーション用のテーブルを計算します。

### `mjai` ディレクトリ

mjaiプロトコルのイベント定義と、それに対応するボットインターフェースを提供します。

*   **`event.rs`:**
    *   **`Event` enum:** mjaiプロトコルで定義されているすべてのイベント（`StartGame`, `StartKyoku`, `Tsumo`, `Dahai`, `Hora` など）をRustのenumとして定義します。
*   **`bot.rs`:**
    *   **`Bot` 構造体:** mjaiプロトコルで通信するボットの実装です。Pythonから利用され、JSON形式のイベント文字列を受け取り、反応をJSON文字列で返します。内部で `MortalBatchAgent` と `PlayerState` を保持しています。

## 3. エージェントモジュール

### `agent` ディレクトリ

様々な麻雀AIエージェントの実装が含まれています。

*   **`defs.rs`:**
    *   **`Agent` trait:** 個別のエージェントが実装すべきインターフェースを定義します。`react` メソッドが中心です。
    *   **`BatchAgent` trait:** 複数のゲームをバッチ処理するエージェントのためのインターフェースです。`set_scene` で状態を設定し、`get_reaction` で行動を取得します。
*   **`tsumogiri.rs`:**
    *   **`Tsumogiri`:** 最も単純なエージェントで、常にツモ切り（引いてきた牌をそのまま捨てる）します。
*   **`akochan.rs`:**
    *   **`AkochanAgent`:** 有名な麻雀AIである[Akochan](https://github.com/critter-mj/Akochan)を外部プロセスとして実行し、通信して行動を決定するエージェントです。
*   **`mortal.rs`:**
    *   **`MortalBatchAgent`:** このプロジェクトの主役である深層学習ベースのエージェントです。Pythonで実装された推論エンジン (`engine`) と連携します。
    *   複数のゲーム状態をバッチとして受け取り、`react_batch` メソッドを介してPython側のモデルに観測情報を渡して推論させ、行動を決定します。
*   **`py_agent.rs`:**
    *   Python側で定義されたエージェントをラップし、Rust側で `BatchAgent` として扱えるようにするためのファクトリ関数 `new_py_agent` を提供します。

## 4. ゲームエミュレーションモジュール

### `arena` ディレクトリ

エージェント同士を対戦させるためのシミュレーション環境を提供します。

*   **`one_vs_three.rs`, `two_vs_two.rs`:**
    *   特定の対戦形式（1対3、2対2）のシミュレーションを実行するための高レベルなインターフェースを提供します。Pythonから直接呼び出されます。
    *   シード値を指定して、再現性のある対戦を実行できます。
    *   対戦ログを指定されたディレクトリに保存する機能も持ちます。
*   **`game.rs`:**
    *   **`BatchGame`:** 複数のゲームを並列で実行するコアロジックです。
    *   `run` メソッドが、指定された数のゲームがすべて終了するまでループを実行します。
    *   ループ内では、各ゲームの `poll`（状態更新と行動選択の準備）と `commit`（行動の取得）を呼び出します。
*   **`board.rs`:**
    *   **`Board`:** 1局ごとの静的な情報（牌山、ドラ、初期スコアなど）を管理します。`init_from_seed` でシード値から牌山を生成します。
    *   **`BoardState`:** 1局の動的な状態遷移を管理します。
    *   `poll` メソッドが、ゲームが進行可能な状態になるまで（＝誰かが行動を選択できる状態になるか、局が終了するまで）内部ループを回します。
    *   `step` メソッドで、プレイヤーからの反応（`reactions`）を処理し、ゲームを1ステップ進めます。
*   **`result.rs`:**
    *   **`GameResult`:** 1ゲームの最終結果を保持します。スコア、プレイヤー名、シード値、そしてすべてのイベントログが含まれます。

## 5. データセット・統計モジュール

### `dataset` ディレクトリ

mjai形式のログファイルから機械学習用のデータセットを生成します。

*   **`gameplay.rs`:**
    *   **`GameplayLoader`:** ログファイルを読み込み、`Gameplay` オブジェクトのリストを生成します。
    *   **`Gameplay`:** 1人のプレイヤーの1ゲーム分の学習データを保持します。観測情報 (`obs`)、行動 (`actions`)、行動マスク (`masks`) などが含まれます。
*   **`grp.rs`:**
    *   **`Grp`:** ゲームの報酬（Game Result Prediction）に関連する特徴量を保持します。各局開始時の点数状況などが含まれます。
*   **`invisible.rs`:**
    *   **`Invisible`:** 他家から見えない情報（山牌、他家の手牌など）をログから再構築します。主にOracleモデル（神視点モデル）の学習データ生成に利用されます。

### `stat.rs`

mjai形式のログファイルから各種統計データを計算します。

*   **`Stat` 構造体:**
    *   和了率、放銃率、立直率、平均和了点、平均順位など、非常に多くの統計項目を保持します。
    *   `from_dir` や `from_log` といったメソッドで、指定されたログから統計を計算します。
    *   `Display` トレイトが実装されており、計算結果を人間が読みやすい形式で出力できます。

## 6. ユーティリティモジュール

*   **`consts.rs`:**
    *   `ACTION_SPACE`（行動空間のサイズ）、`obs_shape`（観測情報の形状）など、モデルに関連する定数を定義します。
*   **`array.rs`, `vec_ops.rs`:**
    *   `ndarray` をラップした `Simple2DArray` や、ベクトル演算のヘルパー関数を提供します。
*   **`macros.rs`:**
    *   `t!`, `tu8!`, `tuz!` など、牌を簡潔に記述するためのマクロを定義します。
*   **`py_helper.rs`:**
    *   Pythonのサブモジュールを正しく登録するためのヘルパー関数 `add_submodule` を提供します。

## 7. バイナリ

`src/bin` ディレクトリには、ライブラリの機能を利用した実行可能なコマンドラインツールが含まれています。

*   **`stat.rs`:**
    *   指定されたディレクトリ内のログファイルをすべて読み込み、特定のプレイヤー名の統計情報を計算して表示します。
*   **`validate_logs.rs`:**
    *   指定されたディレクトリ内のログファイルが、`libriichi` のルールエンジンと矛盾がないか（不正な行動が含まれていないか）を検証します。

以上が `libriichi` ライブラリの全体像と各モジュールの詳細な解説です。
